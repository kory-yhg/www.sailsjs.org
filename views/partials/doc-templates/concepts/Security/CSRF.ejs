<h1>CSRF</h1>
<p>クロスサイトのリクエスト強制(<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">CSRF</a>)はすでに認証されているWebアプリケーションに対してエンドユーザが意図しないリク絵イストを強制するものです。言い換えればこの防御なしにはChase.comで使うためにChromeに保存されたクッキーのデータを今アクセスしているHorrible-Hacker-Site.comのために使われてしまうということです。 </p>
<h3>SCRF防御を有効にする</h3>
<p>Sailsは設定するだけで簡単に使えるオプショナルなCSRF防御策を用意しています。これを有効化するためには<a href="http://sailsjs.jp/documentation/reference/Configuration/CSRF.html">sails.config.csrf</a>(通常プロジェクトの中の<a href="http://sailsjs.jp/documentation/anatomy/myApp/config/csrf.js.html"><code>config/csrf.js</code></a>ファイルに保管されています。)に以下の編集を加えます。:</p>
<pre><code class="language-js">csrf: true</code></pre>
<p>すでにSailsのバックエンドとPOST,PUT,やDELETEで通信しなければならないコードが有る場合、それらの通信はパラメータかヘッダーにCSRFトークンを持たなければならなくなるということにお気をつけ下さい。これから詳しく説明します。</p>
<h3>CSRFトークン</h3>
<p>多くのNodeアプリケーションと同じようにSailsとExpressはこれらの攻撃に対応するための<a href="http://www.senchalabs.org/connect/csrf.html">CSRF protection middleware</a>接続に対応しています。このミドルウエアは<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern">Synchronizer Token Pattern</a>を実装しています。CSRF防御が有効なときにGETでないアクセス方法はHTTPのBodyやクエリストリング、もしくはヘッダーに特別なトークンを持つことで認証されなければなりません。</p>
<p>CSRFトークンは一時的でセッション依存です。例えばマリーとモハメドがSailsで動作しておりCSRF防御が有効になっているいるEコマースサイトにアクセスするとします。月曜日にマリーもモハメドも買い物をするとします。これを実現するにはマリーとモハメドに一つづつ、少なくとも2つの別々のトークンを用意する必要があります。それからWebバックエンドはトークンがないあるいは、トークンが間違っているリクエストを拒否するでしょう。これでマリーがオンラインポーカを使っている時にサードパーティのWebサイトが彼女のブラウザに入り込んでクッキーを使って彼女が意図しないアクセスをすることはできないようになります。</p>
<h3>CSRFトークンを発行する</h3>
<p>CSRFトークンを取得するには<a href="http://sailsjs.jp/documentation/concepts/Views/Locals.html">locals</a>を使ってビューでこれを立ち上げる（昔ながらのマルチーページアプリケーションに向いています）か特別な防御がされているJSONエンドポイントからAJAXやソケットで取得（シングルページアプリケーション（SPA）で便利です。）しなければいけません。</p>
<h5>ビューのローカルを使う:</h5>
<p>古いやり方のフォーム送信ではビューからフォームにデータを渡すのが簡単です。ビューのローカルにアクセス可能な場所からトークンを取得することができます。: <code>&lt;%= _csrf %&gt;</code></p>
<p>e.g.:</p>
<pre><code class="language-html">&lt;form action="/signup" method="POST"&gt;
 &lt;input type="text" name="emailaddress"/&gt;
 &lt;input type='hidden' name='_csrf' value='&lt;%= _csrf %&gt;'&gt;
 &lt;input type='submit'&gt;
&lt;/form&gt;</code></pre>
<p>もしフォームから<code>multipart/form-data</code>を行おうとしている場合は<code>_csrf</code>フィールドが<code>file</code>インプットの前に行われるようにしてください、そうしなければファイルのアップロードが行われる前にタイムアウトして403エラーが発生するおそれがあります。</p>
<h5>AJAX/WebSocketsを使う</h5>
<p>AJAX/Socket多く使うアプリケーションではトークンをJSONで渡すビルトインの<code>/csrfToken</code>ルートを使うといいでしょう。例:</p>
<pre><code class="language-json">{
  "_csrf": "ajg4JD(JGdajhLJALHDa"
}</code></pre>
<h3>CSRFトークンを使う</h3>
<p>CSRF防御を有効にしたらあなたのSailsアプリケーションに対して行われる全てのPOST, PUTあるいはDELETEリクエストはパラメータやヘッダーとしてCSRFトークンをもつ必要があります。さもなければ403 (Forbidden)レスポンスでアクセス拒否されることになります。</p>
<p>もし、jQueryからのAjaxリクエストを送るとしたら:</p>
<pre><code class="language-js">$.post('/checkout', {
  order: '8abfe13491afe',
  electronicReceiptOK: true,
  _csrf: 'USER_CSRF_TOKEN'
}, function andThen(){ ... });</code></pre>
<p>幾つかのクライアントモジュールではAJAXリクエスト自体にアクセス権がりません。このような場合はCSRFトークンをクエリーのURLに直接含ませることを考慮すべきです。しかしこれを行うにはURLのエンコードをトークンが消費される前に行うのを忘れずにいてください。</p>
<pre><code class="language-js">..., {
  checkoutAction: '/checkout?_csrf='+encodeURIComponent('USER_CSRF_TOKEN')
}</code></pre>
<h3>備考</h3>
<blockquote>
<ul>
<li>多くの組織や開発者にとってCSRF防御はユーザがブラウザからログインしたりセキュアなアクセスをするときにのみ必要になるでしょう。もし <em>そうでない</em> 場合、（例えばユーザがネイティブのiOSアプリケーションやAndroidアプリケーションからのみセキュアなアクセスが出来る場合）CSRF防御は必要ないとみなすこともできます。なぜでしょうか？それは厳密にはこのページで取り上げられている一般的なCSRF攻撃は　<em>同じアプリケーション</em>  (例えばChromeなど)をから異なるサイトにアクセスが使うシナリオ（例えばChase.comとHorrible-Hacker-Site.comのような）でのみ <em>可能とされている</em> からです。</li>
<li>CSRFに関してのさらなる情報は<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">Wikipedia</a>をご覧ください。</li>
<li>CSRFトークンを従来のフォーム送信で利用する方法は上の例をご覧下さい。(&quot;Using View Locals&quot;の項目)</li>
<li>CSRFトークンはパラメータの代わりにヘッダーとして送信できます。最新情報に関しては<a href="http://www.senchalabs.org/connect/csrf.html">Connect documentation</a>をご覧ください。 次の（v0.10以降の）マイナーリリースではおそらくSailsはExpress 4を採用します。これで新しいExpressのSCRFミドルウエアが内蔵されることになりますが、後方互換性は確保されます。</li>
</ul>
</blockquote>
<docmeta name="uniqueID" value="CSRF300312">
<docmeta name="displayName" value="CSRF">